"""
Configuration helper for Universal Debezium + dlt integration.

Supports multiple database connectors by configuring Debezium properties
from dlt secrets.toml configuration.
"""
import logging
from pathlib import Path
from typing import Dict, Any

import dlt

logger = logging.getLogger(__name__)


def generate_debezium_properties_file(
    connector_class: str = "io.debezium.connector.postgresql.PostgresConnector",
    db_config_section: str = "sources.debezium.postgres",
) -> Path:
    """
    Generates Debezium properties file from dlt secrets.
    
    Uses a dictionary-based approach for maintainability and extensibility.
    """
    base_path = Path(__file__).resolve().parent
    (base_path / ".dlt").mkdir(exist_ok=True)
    (base_path / "tmp").mkdir(exist_ok=True)

    # 1. Fetch Config (Graceful Fallback)
    db_conf = dlt.secrets.get(db_config_section) or dlt.secrets.get("sources.debezium")
    if not db_conf:
        raise ValueError(
            f"Missing config in secrets.toml: '{db_config_section}' or 'sources.debezium'"
        )
    
    extra_conf = dlt.secrets.get("sources.debezium", {})

    # 2. Define Common Properties (Universal)
    connector_type = "mysql" if "mysql" in connector_class.lower() else "postgres"
    offset_file = base_path / "tmp" / f"offsets_{connector_type}_debezium.dat"
    
    props: Dict[str, Any] = {
        "name": f"debezium_{db_conf.get('database', 'source')}_connector",
        "connector.class": connector_class,
        "database.hostname": db_conf.get('host', 'localhost'),
        "database.port": db_conf.get('port', 3306 if connector_type == 'mysql' else 5432),
        "database.user": db_conf.get('username', db_conf.get('user', '')),
        "database.password": db_conf.get('password', ''),
        "database.server.name": extra_conf.get('server_name', db_conf.get('database', 'source')),
        "topic.prefix": extra_conf.get('topic_prefix', db_conf.get('database', 'source')),
        "table.include.list": extra_conf.get('table_include_list', '.*'),
        "snapshot.mode": extra_conf.get('snapshot_mode', 'initial'),
        
        # Offset Storage (Universal)
        "offset.storage": "org.apache.kafka.connect.storage.FileOffsetBackingStore",
        "offset.storage.file.filename": str(offset_file.absolute()),
        "offset.flush.interval.ms": extra_conf.get('offset_flush_interval_ms', 60000),
    }

    # 3. Apply Connector-Specific Logic
    if connector_type == "postgres":
        props.update({
            "database.dbname": db_conf.get('database', db_conf.get('dbname', '')),
            "plugin.name": "pgoutput",
            "slot.name": extra_conf.get('slot_name', 'debezium_slot'),
            "publication.name": extra_conf.get('publication_name', 'debezium_pub'),
            # Critical: prevent tombstone-only events so we get the 'before' data for deletes
            "tombstones.on.delete": extra_conf.get('tombstones_on_delete', 'false'),
        })
        
    elif connector_type == "mysql":
        server_name = extra_conf.get('server_name') or extra_conf.get('topic_prefix') or db_conf.get('database', 'source')
        props.update({
            "database.server.name": server_name,
            "topic.prefix": server_name,
            "database.server.id": extra_conf.get('server_id', 184054),
            "database.include.list": extra_conf.get('database_include_list', db_conf.get('database', '')),
            # MySQL requires both 'file' and 'file.filename' for offset storage
            "offset.storage.file": str(offset_file.absolute()),
            # Schema history (file-based, not Kafka - required for embedded Debezium)
            "schema.history.internal": "io.debezium.storage.file.history.FileSchemaHistory",
            "schema.history.internal.file.filename": str((base_path / 'tmp' / 'schema_history_mysql.dat').absolute()),
        })

    # 4. Write to File
    props_file = base_path / ".dlt" / "debezium.properties"
    
    def to_prop_val(value: Any) -> str:
        """Convert Python value to Java properties file format."""
        if isinstance(value, bool):
            return str(value).lower()  # True -> "true", False -> "false"
        return str(value)
    
    content = "# Generated by Configuration Helper - DO NOT EDIT\n"
    content += "\n".join(f"{k}={to_prop_val(v)}" for k, v in props.items())
    props_file.write_text(content)
    
    logger.info(f"âœ… Generated properties for {connector_type.upper()} at {props_file}")
    logger.info(f"Connector: {connector_class}")
    return props_file

